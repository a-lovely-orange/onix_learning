# 内存检测

>内核加载器的重要功能之一——内存检测

早期DOS操作系统依赖于BIOS（基本输入/输出系统）来完成物理内存的检测。
BIOS在启动时会进行自检，包括内存检测，并报告可用物理内存的大小


`int 0x15 0xe820`是DOS系统`0x15`系统调用的子功能

## Address Range Descriptor Structure: ARDS

ARDS是一种数据结构（结构体），用于描述内存地址范围，一共16个字节

### 数据结构
| 字节偏移量 | 属性名称     | 描述                           |
| ---------- | ------------ | ------------------------------ |
| **0**      | BaseAddrLow  | 基地址的低32位                 |
| 4          | BaseAddrHigh | 基地址的高32位                 |
| **8**      | LengthLow    | 内存长度的低32位，以字节为单位 |
| 12         | LengthHigh   | 内存长度的高32位，以字节为单位 |
| **16**     | Type         | 本段内存的类型                 |

>由于我们的操作系统是32位，因此基地址高32位为全0，内存长度的高32位也是全0

### Type字段（内存类型）

| Type值 | 名称                 | 描述                                                                                       |
| ------ | -------------------- | ------------------------------------------------------------------------------------------ |
| 1      | AddressRangeMemory   | 这段内存可以被操作系统使用                                                                 |
| 2      | AddressRangeReserved | 内存被使用中或者被系统保留，操作系统不可以使用此内存                                       |
| 其他   | 未定义               | 未定义，将来可能会使用到，目前保留，但是需要操作系统将其同样视为(**AddressRangeReserved**) |

## 系统调用参数意义（需要在系统调用之前给以下寄存器赋值）

| 寄存器/状态位 | 参数用途                                                                                                                                                                                                                                                                                   |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| eax: 0xe8a0   | 子功能号：eax寄存器用来指定子功能号，在内存检测中该功能号设置为`0xe820`                                                                                                                                                                                                                    |
| ebx           | 内存信息需要按类型多次返回，由于每次执行中断都只返回一种类型内存的ARDS结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过ebx告诉BIOS应该返回哪一个ARDS，这就是后续值的作用，第一次调用时一定要把ebx设置为0，ebx的具体值取决于具体BIOS的实现，每次中断返回后，BIOS都会更新这个值 |
| ES:DI         | ARDS缓冲区：BIOS将获取到的内存信息写入此寄存器指向的内存，每次都以ARDS格式返回                                                                                                                                                                                                             |
| ecx           | ARDS结构的字节大小：用来指示BIOS写入的字节数，调用者和BIOS同时支持的大小是20字节，将来也许会扩展此结构                                                                                                                                                                                     |
| edx           | 固定签名为`0x534d4150`，是`SMAP`的`ASCII`码，BIOS将调用者正在请求的内存信息写入`ES:DI`所指向的ARDS缓冲区，再用此签名校验其中的信息                                                                                                                                                         |
|               |

## 系统调用寄存器返回值意义

| 寄存器/状态位 | 参数用途                                                                                                                                                                                        |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| CF位          | 若CF=0，表示调用没有出错；若CF=1，表示调用出错                                                                                                                                                  |
| eax           | 字符串SMAP的ASICC码：`0x534d4150`                                                                                                                                                               |
| ES:DI         | ARDS缓冲区地址，与输入值相同，返回时此结构已经被BIOS填充了内存信息                                                                                                                              |
| ecx           | BIOS写入到ES:DI所指向的ARDS结构中的字节数，BIOS最小写入20字节                                                                                                                                   |
| ebx           | 后续值：下一个ARDS结构的位置。每次中断返回后，BIOS会更新此值，并根据这个值找到下一个ARDS结构，ebx除了刚开始需要手动赋值为0，后面不需要关注该寄存器的值，若CF=0且ebx=0，表示这是最后一个ARDS结构 |


# 执行过程

首先，内存检测是在内核加载器中执行，因此相关代码在`loader.asm`里：
```assembly
detect_memory:
    xor ebx, ebx    ; 将ebx置0

    ; 缓冲区段地址
    mov ax, 0
    mov es, ax

    ; es:di: 结构体的缓冲区位置
    mov edi, ards_buffer
    mov edx, 0x534d4150 ;固定签名：SMAP的ASICC码

.next:
    ; 子功能号
    mov eax, 0xe820
    ; ards结构的大小（字节）
    mov ecx, 20
    ; 调用0x15系统调用（软中断）
    int 0x15

    ; 如果CF置位(CF = 1)，表示出错
    jc error

    ; 将缓存指针指向下一个结构体
    add di, cx

    ; 将结构体数量加一，word表示将ards_count作为word(2 bytes)来看待
    inc word[ards_count]

    ; 判断检测是否结束，!=0：检测未结束；=0：检测结束
    cmp ebx, 0
    jnz .next

    ; 打印结束
    mov si, detecting
    call  print

    xchg bx, bx ; bochs魔数断点

    ; cx：结构体数量，loop循环次数
    mov cx, [ards_count]
    ; si：结构体字段指针(0, 4, 8, 12, 16)
    mov si, 0
.show
    mov eax, [ards_buffer + si]
    mov ebx, [ards_buffer + si + 8]
    mov edx, [ards_buffer + si + 16]
    loop .show
    add si, 20
    xchg bx, bx

; 阻塞
jmp $


; print函数实现
print:
    mov ah, 0x0e
.next:
    mov al, [si]
    cmp al, 0
    jz .done
    int 0x10
    inc si
    jmp .next
.done:
    ret

; 变量生命
loading:    ; loading时出现的字符串
    db "Loading Onix...", 10, 13, 0 ;\n\r
detecting:    ; memory detecting时出现的字符串
    db "Detecting Memory Success!!!", 10, 13, 0 ;\n\r

; 错误处理
error:
    mov si, .msg
    call print
    hlt;
    jmp $
    .msg db "Loading Error!!!", 10, 13, 0

ards_count:
    dw 0
ards_buffer:
```

>注意：由于不同的操作系统内存检测得到的`ards_count`不同，因此`ards_buffer`应该放在程序的最后，以免溢出将后面的程序覆盖

1. 给寄存器赋值
2. 调用`int 0x15`
3. 根据返回值判断是否是否出错或检测完毕
   1. 如果出错，则跳转到`error`
   2. 如果检测完毕，则继续向下执行，打印成功信息
4. 通过寄存器(`eax`, `ebx`, `edx`)看一下所有`ARDS`结构体内的三个字段值，`ecx`不用是因为它要作为循环变量使用